/* ==================================================================
   PROJECT STRUCTURE ANALYZER
   Heuristic analysis functions for project structure
   ================================================================== */

import * as path from 'path';

/* ==================================================================
   MAIN ANALYSIS FUNCTION
   ================================================================== */

export function analyzeProjectStructure(rootPath: string, structure: string): string {
    const projectName = path.basename(rootPath);
    const lines = structure.split('\n').filter(l => l.trim());

    const fileCount = lines.filter(l => l.includes('üìÑ')).length;
    const dirCount = lines.filter(l => l.includes('üìÅ')).length;
    const maxDepth = Math.max(
        ...lines.map(l => {
            const m = l.match(/^(\s*)/);
            return m ? Math.floor(m[1].length / 4) : 0;
        })
    );

    const type = detectProjectType(structure);
    const issues = findStructureIssues(structure);
    const recs = generateRecommendations(structure, type);
    const tech = detectTechnologies(structure);

    return [
        '## üìä Project analysis',
        `- **Name:** ${projectName}`,
        `- **Files:** ${fileCount}`,
        `- **Directories:** ${dirCount}`,
        `- **Depth:** ${maxDepth}`,
        `- **Detected type:** ${type}`,
        '',
        '### ‚ö†Ô∏è Issues',
        issues.length ? issues.map(i => `- ${i}`).join('\n') : 'None',
        '',
        '### üí° Recommendations',
        recs.map(r => `- ${r}`).join('\n'),
        '',
        '### üõ†Ô∏è Detected technologies',
        tech.length ? tech.map(t => `- ${t}`).join('\n') : 'None',
        '',
        '_Generated by Folder Structure Navigator (heuristic analysis)_'
    ].join('\n');
}

/* ==================================================================
   PROJECT TYPE DETECTION
   ================================================================== */

export function detectProjectType(structure: string): string {
    const indicators: Record<string, string[]> = {
        'React/Next.js': ['package.json', 'src/', 'public/', 'components/', 'pages/', 'next.config'],
        'Vue.js': ['package.json', 'src/', 'components/', 'vue.config', '.vue'],
        'Angular': ['package.json', 'src/', 'angular.json', 'tsconfig.json'],
        'Node.js API': ['package.json', 'server', 'routes/', 'controllers/', 'middleware/'],
        'Python': ['requirements.txt', 'setup.py', '__pycache__/', '.py'],
        'Java/Maven': ['pom.xml', 'src/main/java', 'target/'],
        'Java/Gradle': ['build.gradle', 'src/main/java', 'gradle/'],
        'C++': ['.cpp', '.hpp', '.h', 'CMakeLists.txt', 'Makefile'],
        'Go': ['go.mod', 'main.go', '.go'],
        'Rust': ['Cargo.toml', 'src/', '.rs'],
        '.NET': ['.csproj', '.sln', 'bin/', 'obj/'],
        'Documentation': ['README', 'docs/', '.md', 'mkdocs'],
        'Static Site': ['index.html', '_site/', '.jekyll', 'hugo']
    };
    for (const [type, pats] of Object.entries(indicators)) {
        const hits = pats.filter(p => structure.includes(p)).length;
        if (hits >= Math.ceil(pats.length * 0.4)) {
            return type;
        }
    }
    return 'Unknown/Mixed';
}

/* ==================================================================
   STRUCTURE ISSUES DETECTION
   ================================================================== */

export function findStructureIssues(structure: string): string[] {
    const issues: string[] = [];
    const lines = structure.split('\n');

    // deep nesting
    const deep = lines.filter(l => {
        const m = l.match(/^(\s*)/);
        return m && Math.floor(m[1].length / 4) > 8;
    });
    if (deep.length) {
        issues.push(`Very deep nesting (${deep.length} items deeper than 8 levels)`);
    }

    // missing common files
    const common = ['README', 'LICENSE', '.gitignore'];
    const missing = common.filter(f => !structure.toLowerCase().includes(f.toLowerCase()));
    if (missing.length) {
        issues.push(`Missing common files: ${missing.join(', ')}`);
    }

    // potential secret files
    const secrets = ['.env', '.key', '.pem', 'password', 'secret'];
    const found = secrets.filter(s => structure.toLowerCase().includes(s));
    if (found.length) {
        issues.push(`Potentially sensitive files detected: ${found.join(', ')}`);
    }

    return issues;
}

/* ==================================================================
   RECOMMENDATIONS GENERATION
   ================================================================== */

export function generateRecommendations(structure: string, projType: string): string[] {
    const recs: string[] = [];

    if (!structure.includes('README')) {
        recs.push('Add a README.md to describe the project.');
    }
    if (!structure.includes('.gitignore')) {
        recs.push('Create a .gitignore file.');
    }
    if (projType === 'React/Next.js') {
        if (!structure.includes('.eslintrc')) {
            recs.push('Add ESLint configuration.');
        }
        if (!structure.includes('cypress/') && !structure.includes('__tests__/')) {
            recs.push('Add a testing framework (Jest, Cypress, ‚Ä¶).');
        }
    }
    if (projType === 'Node.js API') {
        if (!structure.includes('Dockerfile')) {
            recs.push('Consider containerising with Docker.');
        }
    }
    if (projType === 'Python') {
        if (!structure.includes('requirements.txt') && !structure.includes('pyproject.toml')) {
            recs.push('Add a dependency file (requirements.txt or pyproject.toml).');
        }
        if (!structure.includes('tests/')) {
            recs.push('Add unit tests under a tests/ folder.');
        }
    }

    const fileCount = (structure.match(/üìÑ/g) || []).length;
    if (fileCount > 100) {
        recs.push('Large project ‚Äì consider further sub-folder organization.');
    }

    return recs.length ? recs : ['Project structure looks good! üëç'];
}

/* ==================================================================
   TECHNOLOGY DETECTION
   ================================================================== */

export function detectTechnologies(structure: string): string[] {
    const techMap: Record<string, string[]> = {
        'JavaScript/TypeScript': ['.js', '.ts', '.jsx', '.tsx'],
        Python: ['.py', 'requirements.txt', '__pycache__'],
        Java: ['.java', '.jar', 'pom.xml'],
        'C/C++': ['.c', '.cpp', '.h', '.hpp'],
        Go: ['.go', 'go.mod'],
        Rust: ['.rs', 'Cargo.toml'],
        PHP: ['.php', 'composer.json'],
        Ruby: ['.rb', 'Gemfile'],
        Docker: ['Dockerfile', 'docker-compose'],
        Kubernetes: ['.yaml', '.yml', 'k8s/'],
        Git: ['.git/', '.gitignore'],
        NodeJS: ['package.json', 'node_modules/'],
        Webpack: ['webpack.config'],
        Babel: ['.babelrc', 'babel.config'],
        ESLint: ['.eslintrc'],
        Prettier: ['.prettierrc'],
        Testing: ['jest.config', 'cypress/', '__tests__/', 'test/']
    };
    const found: string[] = [];
    for (const [tech, patterns] of Object.entries(techMap)) {
        if (patterns.some(p => structure.includes(p))) {
            found.push(tech);
        }
    }
    return found;
}
